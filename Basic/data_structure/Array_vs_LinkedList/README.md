# Array

가장 기본적인 자료구조인 `Array`자료구조는 논리적 저장 순서와 물리적 저장 순서가 일치한다.
즉 인덱스로 해당 원소에 직접적으로 접근 할 수 있다. 그래서 찾고자 하는 원소의 인덱스 값을 알고 있으면
`Big-O(1)`라는 짧은 시간복잡도로 해당 원소에 접근 할 수 있다.

하지만 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료 한 뒤에 또 한가지 작업을 추가적으로 해주어야
하기 때문에, 시간이 더 걸린다. 만약 배열의 원소중 어느 원소를 삭제했다면, 배열의 연속적인 특성이 깨지게 된다.
즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 이동시키는데 시간적 비용이 발생하게 되고,
이 경우의 시간 복잡도는 `O(n)`이 된다. 

그렇기 때문에, Array 자료구조에서 삭제 기능에 대한 시간 복잡도의 worst case가 `O(n)`가 된다.

삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면, 모든 원소들의 인덱스를 1씩 옮겨주어야 하므로 이러한 경우에도 
시간 복잡도가 `O(n)`가 된다.

# LinkedList

위의 Array에 대한 문제점을 해결하기 위한 자료구조가 `Linked List`이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 
따라서 이 부분만 다른 값으로 바꿔주면 삽입 삭제를 `O(1)`만에 수행해줄 수 있다.

하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 찾아야하는 Search 과정이 존재해서 첫번째 원소부터 
다 확인해봐야한다는 것이다. Array와는 달리 논리적 저장순서와 물리적 저장 순서가 틀
하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 찾아야하는 Search 과정이 존재해서 첫번째 원소부터 다 확인해봐야한다는 것이다.
Array와는 달리 논리적 저장순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지인 것이다. 이러한 과정 때문에,
어떤 원소를 삭제 또는 추가하고자 할 때, 그 원소를 찾기 위해서 `O(n)`의 추가 시간 복잡도가 발생한다.

결국 Linked list자료구조는 탐색할 때 `O(n)` 시간복잡도를 가지며, 삽입, 삭제에 대해서도 `O(n)`의 시간이 추가적으로 발생하게 된다.
그렇다고 해서 아주 쓸모없는 자료구조는 아니다. 이 Linked Listsms Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용 되었을 때, 그 유용성이 드러난다.




