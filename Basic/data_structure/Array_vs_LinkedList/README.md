# Array

가장 기본적인 자료구조인 `Array`자료구조는 논리적 저장 순서와 물리적 저장 순서가 일치한다.
즉 인덱스로 해당 원소에 직접적으로 접근 할 수 있다. 그래서 찾고자 하는 원소의 인덱스 값을 알고 있으면
`Big-O(1)`라는 짧은 시간복잡도로 해당 원소에 접근 할 수 있다.

하지만 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료 한 뒤에 또 한가지 작업을 추가적으로 해주어야
하기 때문에, 시간이 더 걸린다. 만약 배열의 원소중 어느 원소를 삭제했다면, 배열의 연속적인 특성이 깨지게 된다.
즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 이동시키는데 시간적 비용이 발생하게 되고,
이 경우의 시간 복잡도는 `O(n)`이 된다. 

그렇기 때문에, Array 자료구조에서 삭제 기능에 대한 시간 복잡도의 worst case가 `O(n)`가 된다.

삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면, 모든 원소들의 인덱스를 1씩 옮겨주어야 하므로 이러한 경우에도 
시간 복잡도가 `O(n)`가 된다.

# LinkedList

위의 Array에 대한 문제점을 해결하기 위한 자료구조가 `Linked List`이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 
따라서 이 부분만 다른 값으로 바꿔주면 삽입 삭제를 `O(1)`만에 수행해줄 수 있다.

하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 찾아야하는 Search 과정이 존재해서 첫번째 원소부터 
다 확인해봐야한다는 것이다. Array와는 달리 논리적 저장순서와 물리적 저장 순서가 틀
하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 찾아야하는 Search 과정이 존재해서 첫번째 원소부터 다 확인해봐야한다는 것이다.
Array와는 달리 논리적 저장순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지인 것이다. 이러한 과정 때문에,
어떤 원소를 삭제 또는 추가하고자 할 때, 그 원소를 찾기 위해서 `O(n)`의 추가 시간 복잡도가 발생한다.

결국 Linked list자료구조는 탐색할 때 `O(n)` 시간복잡도를 가지며, 삽입, 삭제에 대해서도 `O(n)`의 시간이 추가적으로 발생하게 된다.
그렇다고 해서 아주 쓸모없는 자료구조는 아니다. 이 Linked Listsms Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용 되었을 때, 그 유용성이 드러난다.

# 실행 시간 비교

이제 직접 파이썬 코드 혹은 C++코드로 테스트 해보자. 시간의 차이가 얼마나 되는지 비교하기 위해서 충분히 큰 수인 10,000,000개믜 아이템을 각각의 연결리스트와 배열에 넣어주고 각각 worst case의 실행시간을 체크한다. 위의 파이썬 코드 혹은 C++코드를 실행시키면 다음과 같은 결과를 얻게된다.
> --- [Linked List] Search Time : 8.371806144714355 seconds ---<br/>--- [Array] Search Time : 3.7696011066436768 seconds ---
위의 결과에서 배열과 연결리스트가 생각보다 차이가 크다. 배열같은 경우는 논리적 물리적 인덱스가 동일하기에 훓으면서 지나가기만 하면되지만, 연결리스트는 그렇지 못하기 때문에 데이터 값을 확인하고 다음 노드로 넘어가고 그리고 다시 데이터값을 확인해보기 때문에 시간이 더욱 걸릴 수 밖에 없다.


